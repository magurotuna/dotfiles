snippet 2D
pub trait TwoDimensionVectorExt {
    fn adj4(&self, row: usize, col: usize) -> Box<dyn Iterator<Item = (usize, usize)>>;
    fn adj8(&self, row: usize, col: usize) -> Box<dyn Iterator<Item = (usize, usize)>>;
}
impl<T> TwoDimensionVectorExt for Vec<Vec<T>> {
    fn adj4(&self, row: usize, col: usize) -> Box<dyn Iterator<Item = (usize, usize)>> {
        let height = self.len() as isize;
        assert!(height > 0);
        let width = self[0].len() as isize;
        assert!(width > 0);
        let adj = [(-1, 0), (1, 0), (0, -1), (0, 1)]
            .iter()
            .filter_map(move |&(dy, dx)| {
                let ny = row as isize + dy;
                let nx = col as isize + dx;
                if 0 <= ny && ny < height && 0 <= nx && nx < width {
                    Some((ny as usize, nx as usize))
                } else {
                    None
                }
            });
        Box::new(adj)
    }
    fn adj8(&self, row: usize, col: usize) -> Box<dyn Iterator<Item = (usize, usize)>> {
        let height = self.len() as isize;
        assert!(height > 0);
        let width = self[0].len() as isize;
        assert!(width > 0);
        let adj = [
            (-1, 0),
            (1, 0),
            (0, -1),
            (0, 1),
            (-1, -1),
            (-1, 1),
            (1, -1),
            (1, 1),
        ]
        .iter()
        .filter_map(move |&(dy, dx)| {
            let ny = row as isize + dy;
            let nx = col as isize + dx;
            if 0 <= ny && ny < height && 0 <= nx && nx < width {
                Some((ny as usize, nx as usize))
            } else {
                None
            }
        });
        Box::new(adj)
    }
}
endsnippet

snippet BINARY_SEARCH
pub trait BinarySearchExt {
    type Item;
    fn lower_bound(&self, value: &Self::Item) -> usize
    where
        Self::Item: Ord;
    fn upper_bound(&self, value: &Self::Item) -> usize
    where
        Self::Item: Ord;
    fn lower_bound_by<P: Fn(&Self::Item) -> bool>(&self, predicate: P) -> usize;
}
impl<T> BinarySearchExt for [T] {
    type Item = T;
    /// Given a ascending-sorted array, find the minimum index `i`
    /// such that the i-th value in the array is greater than or equal to `value`.
    fn lower_bound(&self, value: &Self::Item) -> usize
    where
        Self::Item: Ord,
    {
        let mut ok = self.len() as i64;
        let mut ng = -1_i64;
        while ok - ng > 1 {
            let mid = (ok + ng) / 2;
            if self[mid as usize] >= *value {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok as usize
    }
    /// Given a ascending-sorted array, find the minimum index `i`
    /// such that the i-th value in the array is greater than `value`.
    fn upper_bound(&self, value: &Self::Item) -> usize
    where
        Self::Item: Ord,
    {
        let mut ok = self.len() as i64;
        let mut ng = -1_i64;
        while ok - ng > 1 {
            let mid = (ok + ng) / 2;
            if self[mid as usize] > *value {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok as usize
    }
    /// Given a array, find the minimum index `i`
    /// such that we get `true` when passing `i` to `predicate`.
    /// NOTE: The given array must have monotonicity, which means that
    /// there is at most only one point where the boundary between
    /// satisfying the predicate and not satisfying it.
    fn lower_bound_by<P: Fn(&Self::Item) -> bool>(&self, predicate: P) -> usize {
        let mut ok = self.len() as i64;
        let mut ng = -1_i64;
        while ok - ng > 1 {
            let mid = (ok + ng) / 2;
            if predicate(&self[mid as usize]) {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok as usize
    }
}
endsnippet

snippet COMBINATION
/// 二項係数を mod のもとで求める
/// cf. [よくやる二項係数 (nCk mod. p)、逆元 (a^-1 mod. p) の求め方 - けんちょんの競プロ精進記録](http://drken1215.hatenablog.com/entry/2018/06/08/210000)
pub struct Comb {
    max_size: usize,
    modulo: usize,
    factorical_table: Vec<usize>,
    factorical_inverse_table: Vec<usize>,
    inverse_table: Vec<usize>,
}
impl Comb {
    pub fn new(max_size: usize, modulo: usize) -> Self {
        let max_size = std::cmp::max(10, max_size);
        assert!(max_size <= 10_000_000);
        let mut factorical_table = vec![0; max_size];
        let mut factorical_inverse_table = vec![0; max_size];
        let mut inverse_table = vec![0; max_size];
        factorical_table[0] = 1;
        factorical_table[1] = 1;
        factorical_inverse_table[0] = 1;
        factorical_inverse_table[1] = 1;
        inverse_table[1] = 1;
        for i in 2..max_size {
            factorical_table[i] = factorical_table[i - 1] * i % modulo;
            inverse_table[i] = modulo - inverse_table[modulo % i] * (modulo / i) % modulo;
            factorical_inverse_table[i] =
                factorical_inverse_table[i - 1] * inverse_table[i] % modulo;
        }
        Self {
            max_size,
            modulo,
            factorical_table,
            factorical_inverse_table,
            inverse_table,
        }
    }
    pub fn calc(&self, n: usize, k: usize) -> usize {
        if n < k {
            0
        } else {
            self.factorical_table[n]
                * (self.factorical_inverse_table[k] * self.factorical_inverse_table[n - k]
                    % self.modulo)
                % self.modulo
        }
    }
}
endsnippet

snippet DISJOINT_SET
#[derive(Debug, Clone)]
pub struct DisjointSet {
    parent: Vec<usize>,
    sizes: Vec<i64>,
    rank: Vec<i64>,
}
impl DisjointSet {
    pub fn new(n: usize) -> Self {
        Self {
            parent: (0..n).collect(),
            sizes: vec![1; n],
            rank: vec![0; n],
        }
    }
    pub fn root(&mut self, x: usize) -> Option<usize> {
        if x >= self.parent.len() {
            None
        } else if self.parent[x] == x {
            Some(x)
        } else {
            let px = self.parent[x];
            let root = self.root(px).unwrap();
            self.parent[x] = root;
            Some(root)
        }
    }
    pub fn unite(&mut self, x: usize, y: usize) {
        let x_root = match self.root(x) {
            None => return,
            Some(val) => val,
        };
        let y_root = match self.root(y) {
            None => return,
            Some(val) => val,
        };
        if x_root == y_root {
            return;
        }
        if self.rank[x] < self.rank[y] {
            self.parent[x_root] = y_root;
            self.sizes[y_root] += self.sizes[x_root];
        } else {
            self.parent[y_root] = x_root;
            self.sizes[x_root] += self.sizes[y_root];
            if self.rank[x_root] == self.rank[y_root] {
                self.rank[x_root] += 1;
            }
        }
    }
    pub fn same(&mut self, x: usize, y: usize) -> bool {
        let x_root = match self.root(x) {
            None => return false,
            Some(val) => val,
        };
        let y_root = match self.root(y) {
            None => return false,
            Some(val) => val,
        };
        x_root == y_root
    }
    pub fn size(&mut self, x: usize) -> Option<i64> {
        self.root(x).map(|r| self.sizes[r])
    }
}
endsnippet

snippet GCD
pub fn gcd<T>(a: T, b: T) -> T
where
    T: Int,
{
    if b == T::zero() {
        a
    } else {
        gcd(b, a % b)
    }
}
endsnippet

snippet INT
pub trait Int:
    std::ops::Add<Output = Self>
    + std::ops::Sub<Output = Self>
    + std::ops::Mul<Output = Self>
    + std::ops::Div<Output = Self>
    + std::ops::Rem<Output = Self>
    + std::hash::Hash
    + PartialEq
    + Eq
    + PartialOrd
    + Ord
    + Copy
{
    fn zero() -> Self;
    fn one() -> Self;
    fn next(self) -> Self;
    fn prev(self) -> Self;
    fn sqrt_floor(self) -> Self {
        if self < Self::zero() {
            return Self::zero();
        }
        let two = Self::one().next();
        let mut ok = Self::zero();
        let mut ng = self.next();
        while ng - ok > Self::one() {
            let mid = (ng + ok) / two;
            if mid * mid <= self {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok
    }
    fn is_zero(&self) -> bool {
        *self == Self::zero()
    }
    fn is_one(&self) -> bool {
        *self == Self::one()
    }
    fn div_rem(&self, other: &Self) -> (Self, Self) {
        ((*self) / (*other), (*self) % (*other))
    }
    fn div_floor(&self, other: &Self) -> Self {
        let (d, r) = self.div_rem(other);
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            d.prev()
        } else {
            d
        }
    }
    fn mod_floor(&self, other: &Self) -> Self {
        let r = *self % *other;
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            r + *other
        } else {
            r
        }
    }
}
macro_rules ! impl_int_for_numerics {($ ($ t : ty ) * ) => {$ (impl Int for $ t {fn zero () -> Self {0 } fn one () -> Self {1 } fn next (self ) -> Self {self + Self :: one () } fn prev (self ) -> Self {self - Self :: one () } } ) * } }
impl_int_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
pub fn gcd<T>(a: T, b: T) -> T
where
    T: Int,
{
    if b == T::zero() {
        a
    } else {
        gcd(b, a % b)
    }
}
pub fn lcm<T>(a: T, b: T) -> T
where
    T: Int,
{
    a / gcd(a, b) * b
}
pub fn divosors<T>(n: T) -> Vec<T>
where
    T: Int,
{
    let mut ret = Vec::new();
    let mut cur = T::one();
    loop {
        if cur * cur > n {
            break;
        }
        if n % cur == T::zero() {
            ret.push(cur);
            if cur * cur != n {
                ret.push(n / cur);
            }
        }
        cur = cur.next();
    }
    ret.sort_unstable();
    ret
}
/// Time complexity: O(n log log n)
pub fn lower_primes<T>(n: T) -> Vec<T>
where
    T: Int,
{
    let mut ret = Vec::new();
    if n <= T::one() {
        return ret;
    }
    let mut deque = std::collections::VecDeque::new();
    let mut t = T::one().next();
    while t <= n {
        deque.push_back(t);
        t = t.next();
    }
    let mut p = match deque.pop_front() {
        Some(x) => x,
        None => return ret,
    };
    ret.push(p);
    while p * p <= n {
        deque = deque
            .iter()
            .filter(|&&x| x % p != T::zero())
            .copied()
            .collect();
        p = match deque.pop_front() {
            Some(x) => x,
            None => return ret,
        };
        ret.push(p);
    }
    for n in deque {
        ret.push(n);
    }
    ret
}
/// Time complexity: O(sqrt(n))
pub fn factorize<T>(n: T) -> std::collections::HashMap<T, usize>
where
    T: Int,
{
    let mut ret = std::collections::HashMap::new();
    if n <= T::one() {
        return ret;
    }
    let mut n = n;
    let mut cur = T::one().next();
    loop {
        if cur * cur > n {
            break;
        }
        if n % cur != T::zero() {
            cur = cur.next();
            continue;
        }
        let mut exp = 0;
        while n % cur == T::zero() {
            exp += 1;
            n = n / cur;
        }
        ret.insert(cur, exp);
    }
    if n != T::one() {
        ret.insert(n, 1);
    }
    ret
}
endsnippet

snippet INT_TRAIT
pub trait Int:
    std::ops::Add<Output = Self>
    + std::ops::Sub<Output = Self>
    + std::ops::Mul<Output = Self>
    + std::ops::Div<Output = Self>
    + std::ops::Rem<Output = Self>
    + std::hash::Hash
    + PartialEq
    + Eq
    + PartialOrd
    + Ord
    + Copy
{
    fn zero() -> Self;
    fn one() -> Self;
    fn next(self) -> Self;
    fn prev(self) -> Self;
    fn sqrt_floor(self) -> Self {
        if self < Self::zero() {
            return Self::zero();
        }
        let two = Self::one().next();
        let mut ok = Self::zero();
        let mut ng = self.next();
        while ng - ok > Self::one() {
            let mid = (ng + ok) / two;
            if mid * mid <= self {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok
    }
    fn is_zero(&self) -> bool {
        *self == Self::zero()
    }
    fn is_one(&self) -> bool {
        *self == Self::one()
    }
    fn div_rem(&self, other: &Self) -> (Self, Self) {
        ((*self) / (*other), (*self) % (*other))
    }
    fn div_floor(&self, other: &Self) -> Self {
        let (d, r) = self.div_rem(other);
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            d.prev()
        } else {
            d
        }
    }
    fn mod_floor(&self, other: &Self) -> Self {
        let r = *self % *other;
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            r + *other
        } else {
            r
        }
    }
}
macro_rules ! impl_int_for_numerics {($ ($ t : ty ) * ) => {$ (impl Int for $ t {fn zero () -> Self {0 } fn one () -> Self {1 } fn next (self ) -> Self {self + Self :: one () } fn prev (self ) -> Self {self - Self :: one () } } ) * } }
impl_int_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
endsnippet

snippet MOD_INT
/// 累乗のmod
/// cf. https://github.com/hatoo/competitive-rust-snippets/blob/master/src/modulo.rs
pub fn mod_pow(x: i64, n: i64, m: i64) -> i64 {
    let mut res = 1;
    let mut x = x % m;
    let mut n = n;
    while n > 0 {
        if n & 1 == 1 {
            res = (res * x) % m;
        }
        x = (x * x) % m;
        n >>= 1;
    }
    res
}
/// mod m での a の逆元を求める
/// m と a が互いに素でなければならないことに注意
/// cf. [「1000000007 で割ったあまり」の求め方を総特集！ 〜 逆元から離散対数まで 〜 - Qiita](https://qiita.com/drken/items/3b4fdf0a78e7a138cd9a)
pub fn mod_inv(val: i64, modulo: i64) -> i64 {
    use std::mem::swap;
    let mut a = val;
    let mut b = modulo;
    let mut ret = 1;
    let mut v = 0;
    while b > 0 {
        let t = a / b;
        a -= t * b;
        swap(&mut a, &mut b);
        ret -= t * v;
        swap(&mut ret, &mut v);
    }
    ret %= modulo;
    if ret < 0 {
        ret += modulo;
    }
    ret
}
pub trait IntoModInt {
    /// Create a ModInt instance with modulo 1_000_000_007 (= 10^9 + 7).
    fn mint(&self) -> ModInt;
    /// Create a ModInt instance with any modulo.
    fn mint_with_mod(&self, modulo: Self) -> ModInt;
}
#[derive(Clone, Copy)]
pub struct ModInt {
    value: i64,
    modulo: i64,
}
impl ModInt {
    pub fn new(value: i64, modulo: i64) -> Self {
        let r = value % modulo;
        Self {
            value: if r < 0 { r + modulo } else { r },
            modulo,
        }
    }
}
impl std::fmt::Debug for ModInt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.value)
    }
}
impl std::fmt::Display for ModInt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.value)
    }
}
impl std::ops::Add for ModInt {
    type Output = Self;
    fn add(self, other: Self) -> Self {
        Self::new(self.value + other.value, self.modulo)
    }
}
impl std::ops::Sub for ModInt {
    type Output = Self;
    fn sub(self, other: Self) -> Self {
        Self::new(self.value - other.value, self.modulo)
    }
}
impl std::ops::Mul for ModInt {
    type Output = Self;
    fn mul(self, other: Self) -> Self {
        Self::new(self.value * other.value, self.modulo)
    }
}
impl std::ops::Div for ModInt {
    type Output = Self;
    fn div(self, other: Self) -> Self {
        let inv = mod_inv(other.value, self.modulo);
        Self::new(self.value * inv, self.modulo)
    }
}
impl std::ops::AddAssign for ModInt {
    fn add_assign(&mut self, other: Self) {
        *self = Self::new(self.value + other.value, self.modulo);
    }
}
impl std::ops::SubAssign for ModInt {
    fn sub_assign(&mut self, other: Self) {
        *self = Self::new(self.value - other.value, self.modulo);
    }
}
impl std::ops::MulAssign for ModInt {
    fn mul_assign(&mut self, other: Self) {
        *self = Self::new(self.value * other.value, self.modulo);
    }
}
impl std::ops::DivAssign for ModInt {
    fn div_assign(&mut self, other: Self) {
        let inv = mod_inv(other.value, self.modulo);
        *self = Self::new(self.value * inv, self.modulo);
    }
}
macro_rules ! impl_mod_int {($ ($ t : ty ) * ) => ($ (impl IntoModInt for $ t {fn mint (& self ) -> ModInt {ModInt :: new (* self as i64 , 1_000_000_007 ) } fn mint_with_mod (& self , modulo : $ t ) -> ModInt {ModInt :: new (* self as i64 , modulo as i64 ) } } impl std :: cmp :: PartialEq <$ t > for ModInt {fn eq (& self , other : &$ t ) -> bool {self . value == (* other as i64 ) } } impl std :: ops :: Add <$ t > for ModInt {type Output = Self ; fn add (self , other : $ t ) -> Self {Self :: new (self . value + (other as i64 ) , self . modulo ) } } impl std :: ops :: AddAssign <$ t > for ModInt {fn add_assign (& mut self , other : $ t ) {* self = Self :: new (self . value + (other as i64 ) , self . modulo ) ; } } impl std :: ops :: Sub <$ t > for ModInt {type Output = Self ; fn sub (self , other : $ t ) -> Self {Self :: new (self . value - (other as i64 ) , self . modulo ) } } impl std :: ops :: SubAssign <$ t > for ModInt {fn sub_assign (& mut self , other : $ t ) {* self = Self :: new (self . value - (other as i64 ) , self . modulo ) ; } } impl std :: ops :: Mul <$ t > for ModInt {type Output = Self ; fn mul (self , other : $ t ) -> Self {Self :: new (self . value * (other as i64 ) , self . modulo ) } } impl std :: ops :: MulAssign <$ t > for ModInt {fn mul_assign (& mut self , other : $ t ) {* self = Self :: new (self . value * (other as i64 ) , self . modulo ) ; } } impl std :: ops :: Div <$ t > for ModInt {type Output = Self ; fn div (self , other : $ t ) -> Self {let inv = mod_inv (other as i64 , self . modulo ) ; Self :: new (self . value * inv , self . modulo ) } } impl std :: ops :: DivAssign <$ t > for ModInt {fn div_assign (& mut self , other : $ t ) {let inv = mod_inv (other as i64 , self . modulo ) ; * self = Self :: new (self . value * inv , self . modulo ) ; } } ) * ) }
impl_mod_int ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
endsnippet

snippet PERMUTAION
/// Ported from:
/// - [bluss/permutohedron](https://github.com/bluss/permutohedron)
/// - [hatoo/competitive-rust-snippets](https://github.com/hatoo/competitive-rust-snippets)
pub trait LexicalPermutation {
    /// Return `true` if the slice was permuted, `false` if it is already
    /// at the last ordered permutation.
    fn next_permutation(&mut self) -> bool;
    /// Return `true` if the slice was permuted, `false` if it is already
    /// at the first ordered permutation.
    fn prev_permutation(&mut self) -> bool;
}
impl<T> LexicalPermutation for [T]
where
    T: Ord,
{
    /// Original author in Rust: Thomas Backman <serenity@exscape.org>
    fn next_permutation(&mut self) -> bool {
        if self.len() < 2 {
            return false;
        }
        let mut i = self.len() - 1;
        while i > 0 && self[i - 1] >= self[i] {
            i -= 1;
        }
        if i == 0 {
            return false;
        }
        let mut j = self.len() - 1;
        while j >= i && self[j] <= self[i - 1] {
            j -= 1;
        }
        self.swap(j, i - 1);
        self[i..].reverse();
        true
    }
    fn prev_permutation(&mut self) -> bool {
        if self.len() < 2 {
            return false;
        }
        let mut i = self.len() - 1;
        while i > 0 && self[i - 1] <= self[i] {
            i -= 1;
        }
        if i == 0 {
            return false;
        }
        self[i..].reverse();
        let mut j = self.len() - 1;
        while j >= i && self[j - 1] < self[i - 1] {
            j -= 1;
        }
        self.swap(i - 1, j);
        true
    }
}
endsnippet

snippet RATIONAL
pub trait Int:
    std::ops::Add<Output = Self>
    + std::ops::Sub<Output = Self>
    + std::ops::Mul<Output = Self>
    + std::ops::Div<Output = Self>
    + std::ops::Rem<Output = Self>
    + std::hash::Hash
    + PartialEq
    + Eq
    + PartialOrd
    + Ord
    + Copy
{
    fn zero() -> Self;
    fn one() -> Self;
    fn next(self) -> Self;
    fn prev(self) -> Self;
    fn sqrt_floor(self) -> Self {
        if self < Self::zero() {
            return Self::zero();
        }
        let two = Self::one().next();
        let mut ok = Self::zero();
        let mut ng = self.next();
        while ng - ok > Self::one() {
            let mid = (ng + ok) / two;
            if mid * mid <= self {
                ok = mid;
            } else {
                ng = mid;
            }
        }
        ok
    }
    fn is_zero(&self) -> bool {
        *self == Self::zero()
    }
    fn is_one(&self) -> bool {
        *self == Self::one()
    }
    fn div_rem(&self, other: &Self) -> (Self, Self) {
        ((*self) / (*other), (*self) % (*other))
    }
    fn div_floor(&self, other: &Self) -> Self {
        let (d, r) = self.div_rem(other);
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            d.prev()
        } else {
            d
        }
    }
    fn mod_floor(&self, other: &Self) -> Self {
        let r = *self % *other;
        if (r > Self::zero() && *other < Self::zero())
            || (r < Self::zero() && *other > Self::zero())
        {
            r + *other
        } else {
            r
        }
    }
}
macro_rules ! impl_int_for_numerics {($ ($ t : ty ) * ) => {$ (impl Int for $ t {fn zero () -> Self {0 } fn one () -> Self {1 } fn next (self ) -> Self {self + Self :: one () } fn prev (self ) -> Self {self - Self :: one () } } ) * } }
impl_int_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
pub fn gcd<T>(a: T, b: T) -> T
where
    T: Int,
{
    if b == T::zero() {
        a
    } else {
        gcd(b, a % b)
    }
}
#[derive(Clone, Copy)]
pub struct Rational<T: Int> {
    /// Numerator
    numerator: T,
    /// Denomitor
    denomitor: T,
}
impl<T> std::fmt::Display for Rational<T>
where
    T: Int + std::fmt::Display,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "({} / {})", self.numerator, self.denomitor)
    }
}
impl<T> std::fmt::Debug for Rational<T>
where
    T: Int + std::fmt::Display,
{
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "({} / {})", self.numerator, self.denomitor)
    }
}
impl<T: Int> Rational<T> {
    pub fn new(numerator: T, denomitor: T) -> Rational<T> {
        let mut r = Rational {
            numerator,
            denomitor,
        };
        r.reduce();
        r
    }
    pub fn from_integer(t: T) -> Rational<T> {
        Rational::new(t, T::one())
    }
    pub fn to_integer(&self) -> T {
        self.truncate().numerator
    }
    /// Round value towards zero.
    pub fn truncate(&self) -> Rational<T> {
        Rational::from_integer(self.numerator / self.denomitor)
    }
    /// Round value towards minus infinity.
    pub fn floor(&self) -> Rational<T> {
        if *self < T::zero() {
            Rational::from_integer((self.numerator - self.denomitor + T::one()) / self.denomitor)
        } else {
            Rational::from_integer(self.numerator / self.denomitor)
        }
    }
    /// Round value towards plus infinity.
    pub fn ceil(&self) -> Rational<T> {
        if *self < T::zero() {
            Rational::from_integer(self.numerator / self.denomitor)
        } else {
            Rational::from_integer((self.numerator + self.denomitor - T::one()) / self.denomitor)
        }
    }
    /// Puts self into lowest terms, with denomitor > 0.
    fn reduce(&mut self) {
        assert!(!self.denomitor.is_zero());
        if self.numerator.is_zero() {
            self.denomitor = T::one();
            return;
        }
        if self.numerator == self.denomitor {
            self.numerator = T::one();
            self.denomitor = T::one();
            return;
        }
        let g = gcd(self.numerator, self.denomitor);
        self.numerator = self.numerator / g;
        self.denomitor = self.denomitor / g;
        if self.denomitor < T::zero() {
            self.numerator = T::zero() - self.numerator;
            self.denomitor = T::zero() - self.denomitor;
        }
    }
}
impl<T> From<T> for Rational<T>
where
    T: Int,
{
    fn from(x: T) -> Self {
        Rational::from_integer(x)
    }
}
impl<T> From<(T, T)> for Rational<T>
where
    T: Int,
{
    fn from((numerator, denomitor): (T, T)) -> Self {
        Rational::new(numerator, denomitor)
    }
}
impl<T> PartialEq<Self> for Rational<T>
where
    T: Int,
{
    fn eq(&self, other: &Self) -> bool {
        self.cmp(other) == std::cmp::Ordering::Equal
    }
}
impl<T> Eq for Rational<T> where T: Int {}
impl<T> PartialEq<T> for Rational<T>
where
    T: Int,
{
    fn eq(&self, other: &T) -> bool {
        let other = Self::from_integer(*other);
        *self == other
    }
}
macro_rules ! impl_partial_eq_with_rational_for_numerics {($ ($ t : ty ) * ) => {$ (impl PartialEq < Rational <$ t >> for $ t {fn eq (& self , other : & Rational <$ t > ) -> bool {let r = Rational :: from_integer (* self ) ; r == * other } } ) * } }
impl_partial_eq_with_rational_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
impl<T> Ord for Rational<T>
where
    T: Int,
{
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        if self.denomitor == other.denomitor {
            return if self.denomitor > T::zero() {
                self.numerator.cmp(&other.numerator)
            } else {
                self.numerator.cmp(&other.numerator).reverse()
            };
        }
        if self.numerator == other.numerator {
            return match self.numerator.cmp(&T::zero()) {
                std::cmp::Ordering::Equal => std::cmp::Ordering::Equal,
                std::cmp::Ordering::Greater => self.denomitor.cmp(&other.denomitor).reverse(),
                std::cmp::Ordering::Less => self.denomitor.cmp(&other.denomitor),
            };
        }
        let self_int = self.numerator.div_floor(&self.denomitor);
        let self_rem = self.numerator.mod_floor(&self.denomitor);
        let other_int = other.numerator.div_floor(&other.denomitor);
        let other_rem = other.numerator.mod_floor(&other.denomitor);
        match self_int.cmp(&other_int) {
            std::cmp::Ordering::Greater => std::cmp::Ordering::Greater,
            std::cmp::Ordering::Less => std::cmp::Ordering::Less,
            std::cmp::Ordering::Equal => match (self_rem.is_zero(), other_rem.is_zero()) {
                (true, true) => std::cmp::Ordering::Equal,
                (true, false) => std::cmp::Ordering::Less,
                (false, true) => std::cmp::Ordering::Greater,
                (false, false) => {
                    let self_new = Rational::new(self.denomitor, self_rem);
                    let other_new = Rational::new(other.denomitor, other_rem);
                    self_new.cmp(&other_new).reverse()
                }
            },
        }
    }
}
impl<T> PartialOrd<Self> for Rational<T>
where
    T: Int,
{
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}
impl<T> PartialOrd<T> for Rational<T>
where
    T: Int,
{
    fn partial_cmp(&self, other: &T) -> Option<std::cmp::Ordering> {
        let other = Self::from_integer(*other);
        Some(self.cmp(&other))
    }
}
macro_rules ! impl_partial_ord_with_rational_for_numerics {($ ($ t : ty ) * ) => {$ (impl PartialOrd < Rational <$ t >> for $ t {fn partial_cmp (& self , other : & Rational <$ t > ) -> Option < std :: cmp :: Ordering > {let r = Rational :: from_integer (* self ) ; Some (r . cmp (other ) ) } } ) * } }
impl_partial_ord_with_rational_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
impl<T> std::ops::Add<Self> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn add(self, rhs: Self) -> Self::Output {
        let denom_gcd = gcd(self.denomitor, rhs.denomitor);
        let denom_lcm = (self.denomitor.mul(rhs.denomitor)).div(denom_gcd);
        let self_mul = (rhs.denomitor).div(denom_gcd);
        let rhs_mul = (self.denomitor).div(denom_gcd);
        let numer = self.numerator.mul(self_mul).add(rhs.numerator.mul(rhs_mul));
        Rational::new(numer, denom_lcm)
    }
}
impl<T> std::ops::Add<T> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn add(self, rhs: T) -> Self::Output {
        let rhs = Self::from_integer(rhs);
        self.add(rhs)
    }
}
impl<T> std::ops::AddAssign<Self> for Rational<T>
where
    T: Int,
{
    fn add_assign(&mut self, other: Self) {
        let add = std::ops::Add::<Self>::add(*self, other);
        self.numerator = add.numerator;
        self.denomitor = add.denomitor;
    }
}
impl<T> std::ops::AddAssign<T> for Rational<T>
where
    T: Int,
{
    fn add_assign(&mut self, other: T) {
        let add = std::ops::Add::<T>::add(*self, other);
        self.numerator = add.numerator;
        self.denomitor = add.denomitor;
    }
}
impl<T> std::ops::Sub<Self> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn sub(self, rhs: Self) -> Self::Output {
        let denom_gcd = gcd(self.denomitor, rhs.denomitor);
        let denom_lcm = self.denomitor.mul(rhs.denomitor).div(denom_gcd);
        let self_mul = rhs.denomitor.div(denom_gcd);
        let rhs_mul = self.denomitor.div(denom_gcd);
        let numer = self.numerator.mul(self_mul).sub(rhs.numerator.mul(rhs_mul));
        Rational::new(numer, denom_lcm)
    }
}
impl<T> std::ops::Sub<T> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn sub(self, rhs: T) -> Self::Output {
        let rhs = Self::from_integer(rhs);
        self - rhs
    }
}
impl<T> std::ops::SubAssign<Self> for Rational<T>
where
    T: Int,
{
    fn sub_assign(&mut self, other: Self) {
        let sub = *self - other;
        self.numerator = sub.numerator;
        self.denomitor = sub.denomitor;
    }
}
impl<T> std::ops::SubAssign<T> for Rational<T>
where
    T: Int,
{
    fn sub_assign(&mut self, other: T) {
        let sub = *self - other;
        self.numerator = sub.numerator;
        self.denomitor = sub.denomitor;
    }
}
impl<T> std::ops::Mul<Self> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn mul(self, rhs: Self) -> Self::Output {
        let gcd1 = gcd(self.numerator, rhs.denomitor);
        let gcd2 = gcd(self.denomitor, rhs.numerator);
        let num1 = self.numerator.div(gcd1);
        let den1 = self.denomitor.div(gcd2);
        let num2 = rhs.numerator.div(gcd2);
        let den2 = rhs.denomitor.div(gcd1);
        Self::new(num1 * num2, den1 * den2)
    }
}
impl<T> std::ops::Mul<T> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn mul(self, rhs: T) -> Self::Output {
        let rhs = Self::from_integer(rhs);
        self * rhs
    }
}
impl<T> std::ops::MulAssign<Self> for Rational<T>
where
    T: Int,
{
    fn mul_assign(&mut self, rhs: Self) {
        let mul = *self * rhs;
        self.numerator = mul.numerator;
        self.denomitor = mul.denomitor;
    }
}
impl<T> std::ops::MulAssign<T> for Rational<T>
where
    T: Int,
{
    fn mul_assign(&mut self, rhs: T) {
        let mul = *self * rhs;
        self.numerator = mul.numerator;
        self.denomitor = mul.denomitor;
    }
}
impl<T> std::ops::Div<Self> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn div(self, rhs: Self) -> Self::Output {
        let rhs_inv = Self::new(rhs.denomitor, rhs.numerator);
        std::ops::Mul::<Rational<T>>::mul(self, rhs_inv)
    }
}
impl<T> std::ops::Div<T> for Rational<T>
where
    T: Int,
{
    type Output = Self;
    fn div(self, rhs: T) -> Self::Output {
        let rhs_inv = Self::new(T::one(), rhs);
        std::ops::Mul::<Rational<T>>::mul(self, rhs_inv)
    }
}
impl<T> std::ops::DivAssign<Self> for Rational<T>
where
    T: Int,
{
    fn div_assign(&mut self, rhs: Self) {
        let div = *self / rhs;
        self.numerator = div.numerator;
        self.denomitor = div.denomitor;
    }
}
impl<T> std::ops::DivAssign<T> for Rational<T>
where
    T: Int,
{
    fn div_assign(&mut self, rhs: T) {
        let div = *self / rhs;
        self.numerator = div.numerator;
        self.denomitor = div.denomitor;
    }
}
macro_rules ! impl_ops_for_numerics {($ ($ t : ty ) * ) => {$ (impl std :: ops :: Add < Rational <$ t >> for $ t {type Output = Rational <$ t >; fn add (self , rhs : Rational <$ t > ) -> Self :: Output {Rational :: from_integer (self ) . add (rhs ) } } impl std :: ops :: Sub < Rational <$ t >> for $ t {type Output = Rational <$ t >; fn sub (self , rhs : Rational <$ t > ) -> Self :: Output {Rational :: from_integer (self ) . sub (rhs ) } } impl std :: ops :: Mul < Rational <$ t >> for $ t {type Output = Rational <$ t >; fn mul (self , rhs : Rational <$ t > ) -> Self :: Output {Rational :: from_integer (self ) . mul (rhs ) } } impl std :: ops :: Div < Rational <$ t >> for $ t {type Output = Rational <$ t >; fn div (self , rhs : Rational <$ t > ) -> Self :: Output {Rational :: from_integer (self ) . div (rhs ) } } ) * } }
impl_ops_for_numerics ! (u8 i8 u16 i16 u32 i32 u64 i64 usize isize );
endsnippet

snippet ROLLING_HASH
#[derive(Debug)]
#[doc(hidden)]
pub struct RHMod(u64);
#[derive(Debug)]
#[doc(hidden)]
pub struct RHBase(u64);
#[derive(Debug)]
struct RHInner {
    hash: u64,
    power: u64,
}
#[allow(clippy::redundant_field_names)]
impl RHInner {
    fn new(hash: u64, power: u64) -> RHInner {
        RHInner {
            hash: hash,
            power: power,
        }
    }
}
#[derive(Debug)]
pub struct RollingHash {
    hash_pow_list: Vec<(RHMod, Vec<RHInner>)>,
}
impl RollingHash {
    pub fn new(target: &[char]) -> RollingHash {
        RollingHash::with_base_mod(
            target,
            &[
                (RHBase(2315961251), RHMod(4294966367)),
                (RHBase(1692999586), RHMod(4294959359)),
                (RHBase(1009), RHMod(1_000_000_007)),
            ],
        )
    }
    fn with_base_mod(target: &[char], base_mod: &[(RHBase, RHMod)]) -> RollingHash {
        let hp_list = base_mod
            .iter()
            .map(|&(RHBase(base), RHMod(modulo))| {
                let mut hp = Vec::with_capacity(target.len() + 1);
                hp.push(RHInner::new(0, 1));
                for (i, &c) in target.iter().enumerate() {
                    let RHInner { hash, power } = hp[i];
                    let next_hash = (hash + c as u64) * base % modulo;
                    let next_power = power * base % modulo;
                    hp.push(RHInner::new(next_hash, next_power));
                }
                (RHMod(modulo), hp)
            })
            .collect();
        RollingHash {
            hash_pow_list: hp_list,
        }
    }
    pub fn get(&self, left: usize, right: usize) -> Vec<u64> {
        self.hash_pow_list
            .iter()
            .map(|&(RHMod(modulo), ref hp)| {
                (hp[right].hash + modulo - hp[left].hash * hp[right - left].power % modulo) % modulo
            })
            .collect()
    }
    pub fn equal(&self, left1: usize, right1: usize, left2: usize, right2: usize) -> bool {
        self.get(left1, right1) == self.get(left2, right2)
    }
}
endsnippet

snippet SEG_TREE
#[derive(Debug)]
pub struct SegmentTree<T, F>
where
    T: Clone + Copy,
    F: Fn(T, T) -> T,
{
    values: Vec<T>,
    n_leaves: usize,
    identity_elem: T,
    func: F,
}
impl<T, F> SegmentTree<T, F>
where
    T: Clone + Copy,
    F: Fn(T, T) -> T,
{
    pub fn new(init_value: T, size: usize, func: F) -> Self {
        let mut n = 1;
        while n < size {
            n *= 2;
        }
        Self {
            values: vec![init_value; 2 * n - 1],
            n_leaves: n,
            identity_elem: init_value,
            func,
        }
    }
    pub fn update(&mut self, leaf_number: usize, replace_value: T) {
        let mut node_number = leaf_number + self.n_leaves - 1;
        self.values[node_number] = replace_value;
        while node_number > 0 {
            node_number = (node_number - 1) / 2;
            self.values[node_number] = (self.func)(
                self.values[node_number * 2 + 1],
                self.values[node_number * 2 + 2],
            );
        }
    }
    pub fn query(&self, begin: usize, end: usize) -> T {
        self.internal_query(begin, end, 0, 0, self.n_leaves)
    }
    fn internal_query(
        &self,
        begin: usize,
        end: usize,
        node_number: usize,
        left: usize,
        right: usize,
    ) -> T {
        if right <= begin || end <= left {
            self.identity_elem
        } else if begin <= left && right <= end {
            self.values[node_number]
        } else {
            let c1 = self.internal_query(begin, end, 2 * node_number + 1, left, (left + right) / 2);
            let c2 =
                self.internal_query(begin, end, 2 * node_number + 2, (left + right) / 2, right);
            (self.func)(c1, c2)
        }
    }
}
endsnippet

snippet template
//! https://github.com/hatoo/competitive-rust-snippets
//!
//! MIT License
//!
//! Copyright (c) 2018 hatoo
//!
//! Permission is hereby granted, free of charge, to any person obtaining a copy
//! of this software and associated documentation files (the "Software"), to deal
//! in the Software without restriction, including without limitation the rights
//! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//! copies of the Software, and to permit persons to whom the Software is
//! furnished to do so, subject to the following conditions:
//!
//! The above copyright notice and this permission notice shall be included in all
//! copies or substantial portions of the Software.
//!
//! THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//! SOFTWARE.
#![allow(
    unused_imports,
    unused_attributes,
    unused_macros,
    dead_code,
    non_snake_case
)]
use std::cmp::{max, min, Ordering};
use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};
use std::io::{stdin, stdout, BufWriter, Write};
use std::iter::FromIterator;
#[macro_export]
macro_rules ! get {(@ inner [$ src : expr ] chars ) => {{let mut buf = String :: new () ; $ src . read_line (& mut buf ) . unwrap () ; buf . trim () . chars () . collect ::< Vec < char >> () } } ; (@ inner [$ src : expr ] usize1 ) => {{get ! (@ inner [$ src ] usize ) - 1 } } ; (@ inner [$ src : expr ] [usize1 ] ) => {{get ! (@ inner [$ src ] [usize ] ) . into_iter () . map (| v | v - 1 ) . collect ::< Vec < usize >> () } } ; (@ inner [$ src : expr ] [[usize1 ] ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] [usize1 ] ) ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [usize1 ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] [usize1 ] ) ) . flatten () . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [[chars ] ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] chars ) ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [chars ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] chars ) ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [($ ($ tt : tt ) ,* ) ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] ($ ($ tt ) ,* ) ) ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] ($ ($ tt : tt ) ,* ) ) => {{let mut buf : String = String :: new () ; $ src . read_line (& mut buf ) . unwrap () ; let mut iter = buf . split_whitespace () ; ($ (get ! (@ inner_elem_parse [$ tt ] iter . next () . unwrap () ) , ) * ) } } ; (@ inner [$ src : expr ] [$ t : ty ] ) => {{let mut buf = String :: new () ; $ src . read_line (& mut buf ) . unwrap () ; buf . trim () . split_whitespace () . map (| t | t . parse ::<$ t > () . unwrap () ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [[$ t : ty ] ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] [$ t ] ) ) . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] [$ t : ty ; $ n : expr ] ) => {{(0 ..$ n ) . map (| _ | get ! (@ inner [$ src ] [$ t ] ) ) . flatten () . collect ::< Vec < _ >> () } } ; (@ inner [$ src : expr ] $ t : ty ) => {{let mut buf = String :: new () ; $ src . read_line (& mut buf ) . unwrap () ; buf . trim () . split_whitespace () . next () . unwrap () . parse ::<$ t > () . unwrap () } } ; (@ inner_elem_parse [usize1 ] $ elem : expr ) => {{get ! (@ inner_elem_parse [usize ] $ elem ) - 1 } } ; (@ inner_elem_parse [$ t : ty ] $ elem : expr ) => {{$ elem . parse ::<$ t > () . unwrap () } } ; ($ tt : tt ) => {{use std :: io :: BufRead ; let get_stdin = std :: io :: stdin () ; let mut locked_stdin = get_stdin . lock () ; get ! (@ inner [& mut locked_stdin ] $ tt ) } } ; }
macro_rules ! debug {($ ($ a : expr ) ,* $ (, ) * ) => {# [cfg (debug_assertions ) ] eprintln ! (concat ! ($ ("| " , stringify ! ($ a ) , "={:?} " ) ,*, "|" ) , $ (&$ a ) ,* ) ; } ; }
macro_rules ! echo {($ ($ a : expr ) ,* ) => {let mut s = Vec :: new () ; $ (s . push (format ! ("{}" , $ a ) ) ; ) * println ! ("{}" , s . join (" " ) ) ; } }
#[macro_export]
macro_rules ! chmin {($ base : expr , $ ($ cmps : expr ) ,+ $ (, ) * ) => {{let cmp_min = min ! ($ ($ cmps ) ,+ ) ; if $ base > cmp_min {$ base = cmp_min ; true } else {false } } } ; }
#[macro_export]
macro_rules ! chmax {($ base : expr , $ ($ cmps : expr ) ,+ $ (, ) * ) => {{let cmp_max = max ! ($ ($ cmps ) ,+ ) ; if $ base < cmp_max {$ base = cmp_max ; true } else {false } } } ; }
#[macro_export]
macro_rules ! min {($ a : expr $ (, ) * ) => {{$ a } } ; ($ a : expr , $ b : expr $ (, ) * ) => {{std :: cmp :: min ($ a , $ b ) } } ; ($ a : expr , $ ($ rest : expr ) ,+ $ (, ) * ) => {{std :: cmp :: min ($ a , min ! ($ ($ rest ) ,+ ) ) } } ; }
#[macro_export]
macro_rules ! max {($ a : expr $ (, ) * ) => {{$ a } } ; ($ a : expr , $ b : expr $ (, ) * ) => {{std :: cmp :: max ($ a , $ b ) } } ; ($ a : expr , $ ($ rest : expr ) ,+ $ (, ) * ) => {{std :: cmp :: max ($ a , max ! ($ ($ rest ) ,+ ) ) } } ; }
const BIG_STACK_SIZE: bool = true;
fn main() {
    use std::thread;
    if BIG_STACK_SIZE {
        thread::Builder::new()
            .stack_size(32 * 1024 * 1024)
            .name("solve".into())
            .spawn(solve)
            .unwrap()
            .join()
            .unwrap();
    } else {
        solve();
    }
}
fn solve() {
    todo!();
}
endsnippet

